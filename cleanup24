#!/usr/bin/env scheme-script

#!r7rs

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Converts an AST file into a properly indented AST file.
;;;
;;; Usage:
;;;
;;;     cleanup24 before.ast after.ast
;;;
;;; The before and after files may be the same, in which case
;;; the indented file will replace the input file, assuming no
;;; error occurs.
;;;
;;; FIXME: this program is Larceny-specific.
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(import (scheme base)
        (scheme cxr)
        (scheme file)
        (scheme read)
        (scheme write)
        (only (scheme process-context) exit command-line)
        (primitives pretty-print system condition? display-condition))

(define (first x)  (car x))    ; to improve readability
(define (rest x)   (cdr x))
(define (second x) (first (rest x)))

(define (display-usage-and-exit)
  (display "Usage: cleanup24 before.ast after.json\n")
  (exit 1))

(define cmds (command-line))

;;; Given the name of the output file,
;;; returns a temporary file name for a file in the same directory.

(define (make-temporary-file-name output-file)
  (define (loop n)
    (let ((temp-file (string-append output-file ".temp." (number->string n))))
      (if (file-exists? temp-file)
          (loop (+ n 1))
          temp-file)))
  (loop 1000))

(let ((files (rest (rest cmds))))
  (if (not (= (length files) 2))
      (display-usage-and-exit))
  (let* ((ast (guard (exn
                      ((condition? exn)
                       (display-condition exn)
                       (newline)
                       (exit 1))
                      (else (display "Error:\n")
                            (write exn)
                            (newline)
                            (exit 2)))
               (call-with-input-file (first files) read)))
         (output-file (first (rest files)))
         (temp-file (make-temporary-file-name output-file)))
    (if (or (not (pair? ast))
            (not (eq? 'program (first ast))))
        (begin (display "Input file is not an abstract syntax tree.\n")
               (exit 2)))
    (guard (exn
            ((condition? exn)
             (display-condition exn)
             (newline)
             (delete-file temp-file)
             (exit 1))
            (else (display "Error:\n")
                  (write exn)
                  (newline)
                  (exit 3)))
     (call-with-output-file
      temp-file
      (lambda (out)
        (pretty-print ast out))))
    (exit (system (string-append "mv " temp-file " " output-file)))))
